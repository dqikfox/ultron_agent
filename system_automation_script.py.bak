import ollama
import psutil
import os
import logging
import keyboard
import time
from datetime import datetime

# Configure logging
logging.basicConfig(
    filename='system_automation.loasync def main():
    """Main function to handle user input and process commands."""
    print("System Automation Script with OpenAI/Ollama Integration - system_automation_script.py:13")
    print("Type 'exit' to quit. Enter commands to interact with the system. - system_automation_script.py:14")
    
    use_openai = bool(os.getenv("OPENAI_API_KEY"))
    if use_openai:
        print("Using OpenAI's agent network for enhanced capabilities. - system_automation_script.py:18")
    else:
        print("Using Ollama (qwen2.5) for command processing. - system_automation_script.py:20")
    
    while True:
        command = input("> ")
        if command.lower() == 'exit':
            print("Exiting... - system_automation_script.py:25")
            logging.info("Script terminated by user - system_automation_script.py:26")
            break
        
        result = await process_command(command, use_openai=use_openai)
        print(result)

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())gging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

# Directory for file operations
WORKING_DIR = "automated_files"
if not os.path.exists(WORKING_DIR):
    os.makedirs(WORKING_DIR)
    logging.info(f"Created working directory: {WORKING_DIR} - system_automation_script.py:42")

def run_diagnostics():
    """Run system diagnostics and return results."""
    try:
        cpu_usage = psutil.cpu_percent(interval=1)
        memory = psutil.virtual_memory()
        disk = psutil.disk_usage('/')
        processes = [p.info for p in psutil.process_iter(['name', 'pid'])]
        
        diagnostic_report = (
            f"CPU Usage: {cpu_usage}%\n"
            f"Memory Usage: {memory.percent}% ({memory.used / 1024**3:.2f}/{memory.total / 1024**3:.2f} GB)\n"
            f"Disk Usage: {disk.percent}% ({disk.used / 1024**3:.2f}/{disk.total / 1024**3:.2f} GB)\n"
            f"Running Processes: {len(processes)}\n"
        )
        logging.info("Diagnostics run successfully - system_automation_script.py:58")
        return diagnostic_report
    except Exception as e:
        logging.error(f"Diagnostics error: {str(e)} - system_automation_script.py:61")
        return f"Error running diagnostics: {str(e)}"

def create_file(filename, content, extension=".txt"):
    """Create a file with the specified content and extension."""
    try:
        filepath = os.path.join(WORKING_DIR, f"{filename}{extension}")
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(content)
        logging.info(f"Created file: {filepath} - system_automation_script.py:70")
        return f"File created: {filepath}"
    except Exception as e:
        logging.error(f"File creation error for {filename}{extension}: {str(e)} - system_automation_script.py:73")
        return f"Error creating file: {str(e)}"

def edit_file(filename, content, extension=".txt"):
    """Edit an existing file with new content."""
    try:
        filepath = os.path.join(WORKING_DIR, f"{filename}{extension}")
        if not os.path.exists(filepath):
            return f"File not found: {filepath}"
        with open(filepath, 'a', encoding='utf-8') as f:
            f.write(f"\n{content}")
        logging.info(f"Edited file: {filepath} - system_automation_script.py:84")
        return f"File edited: {filepath}"
    except Exception as e:
        logging.error(f"File edit error for {filename}{extension}: {str(e)} - system_automation_script.py:87")
        return f"Error editing file: {str(e)}"

def delete_file(filename, extension=".txt"):
    """Delete a file."""
    try:
        filepath = os.path.join(WORKING_DIR, f"{filename}{extension}")
        if not os.path.exists(filepath):
            return f"File not found: {filepath}"
        os.remove(filepath)
        logging.info(f"Deleted file: {filepath} - system_automation_script.py:97")
        return f"File deleted: {filepath}"
    except Exception as e:
        logging.error(f"File deletion error for {filename}{extension}: {str(e)} - system_automation_script.py:100")
        return f"Error deleting file: {str(e)}"

def list_files():
    """List all files in the working directory."""
    try:
        files = os.listdir(WORKING_DIR)
        if not files:
            return "No files found in working directory."
        logging.info("Listed files in working directory - system_automation_script.py:109")
        return "\n".join(files)
    except Exception as e:
        logging.error(f"File listing error: {str(e)} - system_automation_script.py:112")
        return f"Error listing files: {str(e)}"

def write_to_active_window(text):
    """Write text to the active window by simulating keystrokes."""
    try:
        time.sleep(1)  # Give user time to focus the target window
        keyboard.write(text)
        keyboard.press_and_release('enter')
        logging.info(f"Wrote to active window: {text[:50]}... - system_automation_script.py:121")
        return "Text written to active window"
    except Exception as e:
        logging.error(f"Error writing to active window: {str(e)} - system_automation_script.py:124")
        return f"Error writing to active window: {str(e)}"

async def process_command(command, use_openai=True):
    """Process a natural language command using OpenAI's agent network or Ollama."""
    try:
        if use_openai and os.getenv("OPENAI_API_KEY"):
            from tools.openai_tools import OpenAITools
            from tools.agent_network import AgentNetwork
            
            config = {"openai_api_key": os.getenv("OPENAI_API_KEY")}
            openai_tools = OpenAITools(config)
            agent_network = AgentNetwork(config)
            
            # Register available system tools
            system_tools = [
                {
                    "type": "function",
                    "function": {
                        "name": "run_diagnostics",
                        "description": "Run system diagnostics to check CPU, memory, disk usage, and processes.",
                        "parameters": {}
                    }
                },
                {
                    "type": "function",
                    "function": {
                        "name": "create_file",
                        "description": "Create a new file with specified content.",
                        "parameters": {
                            "type": "object",
                            "properties": {
                                "filename": {"type": "string"},
                                "content": {"type": "string"},
                                "extension": {"type": "string", "default": ".txt"}
                            },
                            "required": ["filename", "content"]
                        }
                    }
                }
                # Add more tools as needed
            ]
            agent_network.register_tools(system_tools)
            
            result = await agent_network.process_request(command)
            return result["response"]
            
        else:
            # Fallback to Ollama
            english_command = "Please reply in English. " + command
            response = ollama.chat(
                model='qwen2.5',
                messages=[{'role': 'user', 'content': english_command}]
            )
            ollama_response = response['message']['content']
            logging.info(f"Ollama processed command: {command} - system_automation_script.py:179")
            
            # Parse the response to determine the action
            command_lower = command.lower()
        
        if "diagnostics" in command_lower or "system info" in command_lower:
            return run_diagnostics()
        
        elif "create file" in command_lower:
            # Extract filename and content from command or Ollama response
            filename = f"file_{int(datetime.now().timestamp())}"
            extension = ".txt" if "text" in command_lower else ".py"
            return create_file(filename, ollama_response, extension)
        
        elif "edit file" in command_lower:
            filename = command_lower.split("edit file")[-1].strip().split()[0]
            extension = ".txt" if filename.endswith(".txt") else ".py"
            return edit_file(filename.replace(extension, ""), ollama_response, extension)
        
        elif "delete file" in command_lower:
            filename = command_lower.split("delete file")[-1].strip().split()[0]
            extension = ".txt" if filename.endswith(".txt") else ".py"
            return delete_file(filename.replace(extension, ""), extension)
        
        elif "list files" in command_lower:
            return list_files()
        
        elif "write to console" in command_lower or "write to powershell" in command_lower:
            return write_to_active_window(ollama_response)
        
        else:
            # General automation: return the Ollama-generated response or code
            if "python" in command_lower and "script" in command_lower:
                filename = f"script_{int(datetime.now().timestamp())}.py"
                return create_file(filename, ollama_response, ".py")
            return ollama_response
    
    except Exception as e:
        logging.error(f"Ollama command error: {str(e)} - system_automation_script.py:217")
        return f"Error processing command: {str(e)}"

def main():
    """Main function to handle user input and process commands."""
    print("System Automation Script with Ollama (qwen2.5) - system_automation_script.py:222")
    print("Type 'exit' to quit. Enter commands to interact with the system. - system_automation_script.py:223")
    
    while True:
        command = input("> ")
        if command.lower() == 'exit':
            print("Exiting... - system_automation_script.py:228")
            logging.info("Script terminated by user - system_automation_script.py:229")
            break
        
        result = process_ollama_command(command)
        print(result)

if __name__ == "__main__":
    main()
